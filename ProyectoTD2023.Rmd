---
title: "ProyectoTD2023"
author: "Carlos Gómez Sáez"
date: "2023-04-19"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Consideraciones

Para verificar el que la importación de datos es correcta usaremos los
datos de la siguiente carpeta:
'./data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/'.

El número de señales que se deben obtener al leer la cabecera digital
son 10

## Fichero 1: "cabecera_FicheroAnalogico.dat"

LEYENDA CABECERA ANALOGICA:

Siguiente orden:

6 datos (uint8_t) con fecha: dia, mes, año, hora, min, seg

1 datos (uint8_t) del ADC: resolucion (bits)

3 datos (int16_t): vmaxADC(mv), vminADC(vm), Fmuestreo(Hz)

```{r}
# Creamos un objeto de conexión para leer el archivo binario usando el modo "rb"
f1 <- file("./data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroAnalogico.dat", "rb")

# Leemos el fichero 
lect1.1 <- readBin(f1, "integer", n = 7, size = 1, signed = F)
lect1.2 <- readBin(f1, "integer", n = 3, size = 2, signed = T)

# Cerramos el fichero 
close(f1)

# Mostramos la información contenida en el fichero 
print('Lectura 1 cabecera fichero Analógico: ')
lect1.1

print('Lectura 2 cabecera fichero Analógico: ')
lect1.2

```

## Fichero 2: "cabecera_FicheroDigital.dat"

LEYENDA CABECERA DIGITAL:

6 datos (uint8_t) con fecha: dia,mes,año,hora,min,seg

2 datos (uint8_t) FM = 4HZ, CANALES = 9

```{r}
# Creamos un objeto de conexión para leer el archivo binario usando el modo "rb"
f2 <- file("./data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroDigital.dat", "rb")

# Creamos un objeto con la información contenida en el fichero
f2.info <-  file.info("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroDigital.dat")

# Creamos un objeto  con el tamaño del fichero
# Esto nos ayudará a automatizar el parámetro 'n' de la función 'readBin'.
f2.size <- f2.info$size

# Leemos el fichero
lect2 <- readBin(f2, "integer", n = f2.size, size = 1, signed = F)

# Cerramos el fichero 
close(f2)

# Mostramos la información contenida en el fichero 
print(' Lectura cabecera fichero Digital: ')
lect2
```

## Fichero 3: "ficheroAnalogico.dat"

LIBRERÍA NECESARIA: tidyverse

```{r}
# Importamos la librería encesaria:
library(tidyverse)

# Creamos un objeto de conexión para leer el archivo binario usando el modo "rb"
f3 <- file("./data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroAnalogico.dat", "rb")

# Creamos un objeto con la información contenida en el fichero
f3.info <-  file.info("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroAnalogico.dat")

# Creamos un objeto  con el tamaño del fichero
# Esto nos ayudará a automatizar el parámetro 'n' de la función 'readBin'.
f3.size <- f3.info$size

# Leemos el fichero
lect3 <- readBin(f3, "integer", n = f3.size, size = 2L, signed = T)

# Cerramos el fichero 
close(f3)

# Mostramos la información contenida en el fichero 
print('Lectura fichero Analógico: ')
lect3

# Establecemos la frecuencia de muestreo del fichero
Fm <- 1000

# Calculamos el eje temporal para el gráfico
t <- seq(0, (length(lect3)-1)/Fm, by = 1/Fm)

# Graficamos los datos
plot(t, lect3, type = "l", col = "black", xlab = "Tiempo (s)", ylab = "Voltaje (mV)")

# Buscamos el voltaaje máximo
vmax <- max(lect3)

# Calculamos el tiempo acorde a las horas, minutos y segundos
hora <- ((length(lect3)/Fm)/60)/60
min <- (hora - hora) * 60
seg <- (min - min) * 60

# Mostramos la duración del registro 
cat(sprintf("Tiempo de registro: %d horas, %d minutos y %d segundos \n", floor(hora), floor(min), floor(seg)))

# Mostramos la frecuencia del registro
cat(sprintf("Frecuencia de muestreo: %i Hz \n", Fm))

# Mostramos el voltaje máximo del registro
cat(sprintf("Voltaje máximo: %d miliVoltios \n", vmax))
```

## Fichero 4: "ficheroDigital.dat"

```{r}
# Librerías necesarias para graficar el fichero
library(ggplot2)
library(reshape2)

# Creamos un objeto de conexión para leer el archivo binario usando el modo "rb"
f4 <- file("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroDigital.dat", "rb")

# Creamos un objeto con la información contenida en el fichero
f4.info <-  file.info("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroDigital.dat")

# Creamos un objeto  con el tamaño del fichero
# Esto nos ayudará a automatizar el parámetro 'n' de la función 'readBin'.
f4.size <- f4.info$size

# Leemos el fichero
lect4 <- readBin(f4, what = "integer", n = f4.size, size = 1, signed = F)

# Cerramos el fichero 
close(f4)

# Mostramos la información contenida en el fichero 
print(' Lectura fichero Digital: ')
lect4

# Seleccionamos los datos leídos para cada uno de los 9 canales.
HR1 <- lect4[seq(1, length(lect4), 9)]
HR2 <- lect4[seq(2, length(lect4), 9)]
MHR <- lect4[seq(3, length(lect4), 9)]
TOCO <- lect4[seq(4, length(lect4), 9)]
SPO2 <- lect4[seq(5, length(lect4), 9)]
VCP <- lect4[seq(6, length(lect4), 9)]
Ps <- lect4[seq(7, length(lect4), 9)]
Pd <- lect4[seq(8, length(lect4), 9)]
Pm <- lect4[seq(9, length(lect4), 9)]

# Calculamos la media de la VCP (necesaria para la representación gráfica)
mediaVCP <- mean(VCP)

# Creamos una lista con los diferentes canales
channels <- list(HR1 = HR1, HR2 = HR2, MHR = MHR, TOCO = TOCO, 
                 MSpO2 = SPO2, VCP = VCP, Psistolica = Ps, 
                 Pdiastolica = Pd, Pmedia = Pm)

# Crear los data frames
df_HR1 <- data.frame(x = seq_along(HR1), y = HR1, channel = "HR1")
df_HR2 <- data.frame(x = seq_along(HR2), y = HR2, channel = "HR2")
df_MHR <- data.frame(x = seq_along(MHR), y = MHR, channel = "MHR")
df_TOCO <- data.frame(x = seq_along(TOCO), y = TOCO, channel = "TOCO")
df_SPO2 <- data.frame(x = seq_along(SPO2), y = SPO2, channel = "SPO2")
df_VCP <- data.frame(x = seq_along(VCP), y = VCP, channel = "VCP")
df_Ps <- data.frame(x = seq_along(Ps), y = Ps, channel = "Ps")
df_Pd <- data.frame(x = seq_along(Pd), y = Pd, channel = "Pd")
df_Pm <- data.frame(x = seq_along(Pm), y = Pm, channel = "Pm")

# Unir todos los data frames
df_all <- rbind(df_HR1, df_HR2, df_MHR, df_SPO2, df_Pd, df_Pm, df_Ps, df_TOCO, df_VCP)

# Convertir los datos a formato largo
df_all_melt <- melt(df_all, id.vars = c("x", "channel"))

# Graficar usando ggplot2
ggplot(df_all_melt, aes(x = x, y = value, color = channel)) +
  geom_line() +
  labs(title = "Gráficas de los canales del archivo") +
  scale_color_manual(values = c("#E41A1C", "#FF7F00", "#4DAF4A", "#377EB8", "#984EA3", "#000000", "#41AE76", "#FDBF6F", "#A65628")) +
  facet_wrap(~ channel, scales = "free_y") +
  ylab("") +
  xlab("") +
  theme(legend.position = "none")
```

# Automatización

Una vez hecha la importación y visualización a partir de los ficheros en
la carpeta de pruebas. Hemos verificado el correcto funcionamiento, es
decir, lo que hemos obtenido era lo esperado.

El proceso de automatización se llevará a cabo a partir de crear 4
funciones que nos permitirán realizar la lectura y visualización de los
ficheros sin tener que escribir de nuevo el código entero.

## Creación de vectores

Esto se llevará a cabo por carpetas, para ello se creará un vector por
carpeta encontrada cuyo contenido sean los 4 ficheros que vamos a
tratar.

Hemos detectado 4 carpetas principales:

-   "data/0519xxxiii14/06_02_2023"

-   "data/0795xalvii8a7/27_09_2022"

-   "data/1059xlxveei79_ECGf2/27_09_2022"

-   "data/ecg5_210xlxi81_IP_39_eBR_BRP_720"

Dos de ellas contienten, a parte, otras dos carpetas más, por lo tanto
habrá más de 4 vectores a usar. Como es obvio, cada vector contendrá las
rutas de los ficheros a importar y visualizar, es por ello que tendrá 4
componentes el vector.

### Carpeta 1: "data/0519xxxiii14/06_02_2023"
```{r}
v1 <- c("data/0519xxxiii14/06_02_2023/14.20.34/cabecera_FicheroAnalogico.dat",
        "data/0519xxxiii14/06_02_2023/14.20.34/cabecera_FicheroDigital.dat",
        "data/0519xxxiii14/06_02_2023/14.20.34/ficheroAnalogico.dat",
        "data/0519xxxiii14/06_02_2023/14.20.34/ficheroDigital.dat")
```

### Carpeta 2: "data/0795xalvii8a7/27_09_2022"

```{r}
v2 <- c("data/0795xalvii8a7/27_09_2022/10.11.00/cabecera_FicheroAnalogico.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.00/cabecera_FicheroDigital.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.00/ficheroAnalogico.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.00/ficheroDigital.dat")

v3 <- c("data/0795xalvii8a7/27_09_2022/10.11.12/cabecera_FicheroAnalogico.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.12/cabecera_FicheroDigital.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.12/ficheroAnalogico.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.12/ficheroDigital.dat")
```

### Carpeta 3: "data/1059xlxveei79_ECGf2/27_09_2022"

```{r}
v4 <- c("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroAnalogico.dat",
        "data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroDigital.dat",
        "data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroAnalogico.dat",
        "data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroDigital.dat")
```

### Carpeta 4: "data/ecg5_210xlxi81_IP_39_eBR_BRP_720"
```{r}
v5 <- c("data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.31.15/cabecera_FicheroAnalogico.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.31.15/cabecera_FicheroDigital.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.31.15/ficheroAnalogico.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.31.15/ficheroDigital.dat")

v6 <- c("data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.49.57/cabecera_FicheroAnalogico.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.49.57/cabecera_FicheroDigital.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.49.57/ficheroAnalogico.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.49.57/ficheroDigital.dat")
```

