---
title: "ProyectoTD2023"
author: "Carlos Gómez Sáez"
date: "2023-04-19"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Consideraciones

Para verificar el que la importación de datos es correcta usaremos los
datos de la siguiente carpeta:
'./data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/'.

El número de señales que se deben obtener al leer la cabecera digital
son 10

# Librerías

Cargamos todas las librerías necesarias para este proyecto

```{r eval=T, include=F}
# Especificamos las librerías necesarias en esta lista
packages = c("knitr", "ggplot2","tidyr","reshape2","tidyverse")# use this function to check if each package is on the local machine
# if a package is installed, it will be loaded
# if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
    library(x, character.only = TRUE)
  }
})
# verify they are loaded
search()
```

## Fichero 1: "cabecera_FicheroAnalogico.dat"

LEYENDA CABECERA ANALOGICA:

Siguiente orden:

6 datos (uint8_t) con fecha: dia, mes, año, hora, min, seg

1 datos (uint8_t) del ADC: resolucion (bits)

3 datos (int16_t): vmaxADC(mv), vminADC(vm), Fmuestreo(Hz)

```{r}
# Creamos un objeto de conexión para leer el archivo binario usando el modo "rb"
f1 <- file("./data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroAnalogico.dat", "rb")

# Leemos el fichero 
lect1.1 <- readBin(f1, "integer", n = 7, size = 1, signed = F)
lect1.2 <- readBin(f1, "integer", n = 3, size = 2, signed = T)

# Cerramos el fichero 
close(f1)

# Mostramos la información contenida en el fichero 
print('Lectura 1 cabecera fichero Analógico: ')
lect1.1

print('Lectura 2 cabecera fichero Analógico: ')
lect1.2

```

## Fichero 2: "cabecera_FicheroDigital.dat"

LEYENDA CABECERA DIGITAL:

6 datos (uint8_t) con fecha: dia,mes,año,hora,min,seg

2 datos (uint8_t) FM = 4HZ, CANALES = 9

```{r}
# Creamos un objeto de conexión para leer el archivo binario usando el modo "rb"
f2 <- file("./data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroDigital.dat", "rb")

# Creamos un objeto con la información contenida en el fichero
f2.info <-  file.info("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroDigital.dat")

# Creamos un objeto  con el tamaño del fichero
# Esto nos ayudará a automatizar el parámetro 'n' de la función 'readBin'.
f2.size <- f2.info$size

# Leemos el fichero
lect2 <- readBin(f2, "integer", n = f2.size, size = 1, signed = F)

# Cerramos el fichero 
close(f2)

# Mostramos la información contenida en el fichero 
print(' Lectura cabecera fichero Digital: ')
lect2
```

## Fichero 3: "ficheroAnalogico.dat"

LIBRERÍA NECESARIA: tidyverse

```{r}
# Creamos un objeto de conexión para leer el archivo binario usando el modo "rb"
f3 <- file("./data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroAnalogico.dat", "rb")

# Creamos un objeto con la información contenida en el fichero
f3.info <-  file.info("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroAnalogico.dat")

# Creamos un objeto  con el tamaño del fichero
# Esto nos ayudará a automatizar el parámetro 'n' de la función 'readBin'.
f3.size <- f3.info$size

# Leemos el fichero
lect3 <- readBin(f3, "integer", n = f3.size, size = 2L, signed = T)

# Cerramos el fichero 
close(f3)

# Mostramos la información contenida en el fichero 
print('Lectura fichero Analógico: ')
lect3

# Establecemos la frecuencia de muestreo del fichero
Fm <- 1000

# Calculamos el eje temporal para el gráfico
t <- seq(0, (length(lect3)-1)/Fm, by = 1/Fm)

# Graficamos los datos
plot(t, lect3, type = "l", col = "black", xlab = "Tiempo (s)", ylab = "Voltaje (mV)")

# Buscamos el voltaaje máximo
vmax <- max(lect3)

# Calculamos el tiempo acorde a las horas, minutos y segundos
hora <- ((length(lect3)/Fm)/60)/60
min <- (hora - hora) * 60
seg <- (min - min) * 60

# Mostramos la duración del registro 
cat(sprintf("Tiempo de registro: %d horas, %d minutos y %d segundos \n", floor(hora), floor(min), floor(seg)))

# Mostramos la frecuencia del registro
cat(sprintf("Frecuencia de muestreo: %i Hz \n", Fm))

# Mostramos el voltaje máximo del registro
cat(sprintf("Voltaje máximo: %d miliVoltios \n", vmax))
```

## Fichero 4: "ficheroDigital.dat"

```{r}
# Creamos un objeto de conexión para leer el archivo binario usando el modo "rb"
f4 <- file("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroDigital.dat", "rb")

# Creamos un objeto con la información contenida en el fichero
f4.info <-  file.info("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroDigital.dat")

# Creamos un objeto  con el tamaño del fichero
# Esto nos ayudará a automatizar el parámetro 'n' de la función 'readBin'.
f4.size <- f4.info$size

# Leemos el fichero
lect4 <- readBin(f4, what = "integer", n = f4.size, size = 1, signed = F)

# Cerramos el fichero 
close(f4)

# Mostramos la información contenida en el fichero 
print(' Lectura fichero Digital: ')
lect4

# Seleccionamos los datos leídos para cada uno de los 9 canales.
HR1 <- lect4[seq(1, length(lect4), 9)]
HR2 <- lect4[seq(2, length(lect4), 9)]
MHR <- lect4[seq(3, length(lect4), 9)]
TOCO <- lect4[seq(4, length(lect4), 9)]
SPO2 <- lect4[seq(5, length(lect4), 9)]
VCP <- lect4[seq(6, length(lect4), 9)]
Ps <- lect4[seq(7, length(lect4), 9)]
Pd <- lect4[seq(8, length(lect4), 9)]
Pm <- lect4[seq(9, length(lect4), 9)]

# Calculamos la media de la VCP (necesaria para la representación gráfica)
mediaVCP <- mean(VCP)

# Creamos una lista con los diferentes canales
channels <- list(HR1 = HR1, HR2 = HR2, MHR = MHR, TOCO = TOCO, 
                 MSpO2 = SPO2, VCP = VCP, Psistolica = Ps, 
                 Pdiastolica = Pd, Pmedia = Pm)

# Crear los data frames
df_HR1 <- data.frame(x = seq_along(HR1), y = HR1, channel = "HR1")
df_HR2 <- data.frame(x = seq_along(HR2), y = HR2, channel = "HR2")
df_MHR <- data.frame(x = seq_along(MHR), y = MHR, channel = "MHR")
df_TOCO <- data.frame(x = seq_along(TOCO), y = TOCO, channel = "TOCO")
df_SPO2 <- data.frame(x = seq_along(SPO2), y = SPO2, channel = "SPO2")
df_VCP <- data.frame(x = seq_along(VCP), y = VCP, channel = "VCP")
df_Ps <- data.frame(x = seq_along(Ps), y = Ps, channel = "Ps")
df_Pd <- data.frame(x = seq_along(Pd), y = Pd, channel = "Pd")
df_Pm <- data.frame(x = seq_along(Pm), y = Pm, channel = "Pm")

# Unir todos los data frames
df_all <- rbind(df_HR1, df_HR2, df_MHR, df_SPO2, df_Pd, df_Pm, df_Ps, df_TOCO, df_VCP)

# Convertir los datos a formato largo
df_all_melt <- melt(df_all, id.vars = c("x", "channel"))

# Graficar usando ggplot2
ggplot(df_all_melt, aes(x = x, y = value, color = channel)) +
  geom_line() +
  labs(title = "Gráficas de los canales del archivo") +
  scale_color_manual(values = c("#E41A1C", "#FF7F00", "#4DAF4A", "#377EB8", "#984EA3", "#000000", "#41AE76", "#FDBF6F", "#A65628")) +
  facet_wrap(~ channel, scales = "free_y") +
  ylab("") +
  xlab("") +
  theme(legend.position = "none")
```

# Automatización

Una vez hecha la importación y visualización a partir de los ficheros en
la carpeta de pruebas. Hemos verificado el correcto funcionamiento, es
decir, lo que hemos obtenido era lo esperado.

El proceso de automatización se llevará a cabo a partir de crear 4
funciones que nos permitirán realizar la lectura y visualización de los
ficheros sin tener que escribir de nuevo el código entero.

## Creación de vectores

Esto se llevará a cabo por carpetas, para ello se creará un vector por
carpeta encontrada cuyo contenido sean los 4 ficheros que vamos a
tratar.

Hemos detectado 4 carpetas principales:

-   "data/0519xxxiii14/06_02_2023"

-   "data/0795xalvii8a7/27_09_2022"

-   "data/1059xlxveei79_ECGf2/27_09_2022"

-   "data/ecg5_210xlxi81_IP_39_eBR_BRP_720"

Dos de ellas contienten, a parte, otras dos carpetas más, por lo tanto
habrá más de 4 vectores a usar. Como es obvio, cada vector contendrá las
rutas de los ficheros a importar y visualizar, es por ello que tendrá 4
componentes el vector.

### Carpeta 1: "data/0519xxxiii14/06_02_2023"
```{r}
v1 <- c("data/0519xxxiii14/06_02_2023/14.20.34/cabecera_FicheroAnalogico.dat",
        "data/0519xxxiii14/06_02_2023/14.20.34/cabecera_FicheroDigital.dat",
        "data/0519xxxiii14/06_02_2023/14.20.34/ficheroAnalogico.dat",
        "data/0519xxxiii14/06_02_2023/14.20.34/ficheroDigital.dat")
```

### Carpeta 2: "data/0795xalvii8a7/27_09_2022"

```{r}
v2 <- c("data/0795xalvii8a7/27_09_2022/10.11.00/cabecera_FicheroAnalogico.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.00/cabecera_FicheroDigital.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.00/ficheroAnalogico.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.00/ficheroDigital.dat")

v3 <- c("data/0795xalvii8a7/27_09_2022/10.11.12/cabecera_FicheroAnalogico.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.12/cabecera_FicheroDigital.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.12/ficheroAnalogico.dat",
        "data/0795xalvii8a7/27_09_2022/10.11.12/ficheroDigital.dat")
```

### Carpeta 3: "data/1059xlxveei79_ECGf2/27_09_2022"

```{r}
v4 <- c("data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroAnalogico.dat",
        "data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/cabecera_FicheroDigital.dat",
        "data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroAnalogico.dat",
        "data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/ficheroDigital.dat")
```

### Carpeta 4: "data/ecg5_210xlxi81_IP_39_eBR_BRP_720"
```{r}
v5 <- c("data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.31.15/cabecera_FicheroAnalogico.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.31.15/cabecera_FicheroDigital.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.31.15/ficheroAnalogico.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.31.15/ficheroDigital.dat")

v6 <- c("data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.49.57/cabecera_FicheroAnalogico.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.49.57/cabecera_FicheroDigital.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.49.57/ficheroAnalogico.dat",
        "data/ecg5_210xlxi81_IP_39_eBR_BRP_720/12.49.57/ficheroDigital.dat")
```


## Creación de funciones

Las funciones que se implementarán en este apartado son simplemente una adaptación, sin comentarios, de las funciones utilizadas en el apartado "Lectura de ficheros".

Serán 4 funciones, dos que se ocuparán de la lectura de los ficheros y otras dos que se ocuparán de la visualización de los datos.

Esto se ha realizado de esta forma ya que la lectura del Fichero 1: "cabecera_FicheroAnalogico.dat" tiene una lectura diferente a su homólogo, "cabecera_FicheroDigital.dat". Es por esta razón que hemos decidido realizar dos funciones.

Pasa lo mismo para los Ficheros 3 y 4. Se van a implementar dos funciones distintas de visualización ya que estos ficheros difieren en cuanto a la información que se deberá graficar.

### Función 1: lectura "cabecera_FicheroAnalogico.dat"

```{r}
lectura1 <- function(ruta) {
  f <- file(ruta, "rb")
  lect1 <- readBin(f, "integer", n = 7, size = 1, signed = F)
  lect2 <- readBin(f, "integer", n = 3, size = 2, signed = T)
  close(f)
  
  # Devolvemos los valores leídos
  return(list(lect1 = lect1, lect2 = lect2))
}
```

### Función 2: lectura "cabecera_FicheroDigital.dat", "ficheroAnalogico.dat" y "ficheroDigital.dat"

En esta función se han de pasar como parámetros 'size' y 'signed' ya que para cada fichero se utiliza un valor distinto.

```{r}
lectura2 <- function(ruta, size = size, signed = signed) {
  f <- file(ruta, "rb")
  f.info <- file.info(ruta)
  f.size <- f.info$size
  lect <- readBin(f, "integer", n = f.size, size = size, signed = signed)
  close(f)

  # Devolvemos el contenido del fichero
  return(lect)
}
```

### Función 3: visuzalizar "ficheroAnalogico.dat"

En esta función el parámerto 'Fm' se ha establecido como constante ya que todos los ficheros que se han de visualizar son del mismo tipo y, por ende, tienen la misma frecuencia de muestreo.

```{r}
visualizar1 <- function(lect, Fm = 1000) {
  t <- seq(0, (length(lect)-1)/Fm, by = 1/Fm)
  
  plot(t, lect, type = "l", col = "black", xlab = "Tiempo (s)", ylab = "Voltaje (mV)")
  
  vmax <- max(lect)
  
  hora <- ((length(lect)/Fm)/60)/60
  min <- (hora - hora) * 60
  seg <- (min - min) * 60
  
  cat(sprintf("Tiempo de registro: %d horas, %d minutos y %d segundos \n", floor(hora), floor(min), floor(seg)))
  
  cat(sprintf("Frecuencia de muestreo: %i Hz \n", Fm))
  
  cat(sprintf("Voltaje máximo: %d miliVoltios \n", vmax))
}
```

### Función 4: visualizar "ficheroDigital.dat"

```{r}
visualizar2 <- function(lect) {
  HR1 <- lect[seq(1, length(lect), by = 9)]
  HR2 <- lect[seq(2, length(lect), by = 9)]
  MHR <- lect[seq(3, length(lect), by = 9)]
  TOCO <- lect[seq(4, length(lect), by = 9)]
  SPO2 <- lect[seq(5, length(lect), by = 9)]
  VCP <- lect[seq(6, length(lect), by = 9)]
  Ps <- lect[seq(7, length(lect), by = 9)]
  Pd <- lect[seq(8, length(lect), by = 9)]
  Pm <- lect[seq(9, length(lect), by = 9)]
  mediaVCP <- mean(VCP)

  channels <- list(HR1 = HR1, HR2 = HR2, MHR = MHR, TOCO = TOCO, 
                   MSpO2 = SPO2, VCP = VCP, Psistolica = Ps, 
                   Pdiastolica = Pd, Pmedia = Pm)

  df_HR1 <- data.frame(x = seq_along(HR1), y = HR1, channel = "HR1")
  df_HR2 <- data.frame(x = seq_along(HR2), y = HR2, channel = "HR2")
  df_MHR <- data.frame(x = seq_along(MHR), y = MHR, channel = "MHR")
  df_TOCO <- data.frame(x = seq_along(TOCO), y = TOCO, channel = "TOCO")
  df_SPO2 <- data.frame(x = seq_along(SPO2), y = SPO2, channel = "SPO2")
  df_VCP <- data.frame(x = seq_along(VCP), y = VCP, channel = "VCP")
  df_Ps <- data.frame(x = seq_along(Ps), y = Ps, channel = "Ps")
  df_Pd <- data.frame(x = seq_along(Pd), y = Pd, channel = "Pd")
  df_Pm <- data.frame(x = seq_along(Pm), y = Pm, channel = "Pm")

  df_all <- rbind(df_HR1, df_HR2, df_MHR, df_SPO2, df_Pd, df_Pm, df_Ps, df_TOCO, df_VCP)

  df_all_melt <- melt(df_all, id.vars = c("x", "channel"))

  ggplot(df_all_melt, aes(x = x, y = value, color = channel)) +
    geom_line() +
    labs(title = "Gráficas de los canales del archivo") +
    scale_color_manual(values = c("#E41A1C", "#FF7F00", "#4DAF4A", "#377EB8", "#984EA3", "#000000", "#41AE76", "#FDBF6F", "#A65628")) +
    facet_wrap(~ channel, scales = "free_y") +
    ylab("") +
    xlab("") +
    theme(legend.position = "none")
}
```

## Ejecución

### Carpeta 1

```{r}
# Vector 1
cabecera_fa  <- lectura1(v1[1])
cabecera_fd <- lectura2(v1[2], size = 1,signed = F)
fichero_a <- lectura2(v1[3], size = 2,signed = T)
fichero_d <- lectura2(v1[4], size = 1,signed = F)
  
visualizar1(fichero_a, Fm)
visualizar2(fichero_d)
```








